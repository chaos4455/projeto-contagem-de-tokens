# Documenta√ß√£o T√©cnica: export_wordlistv2.py

> Documenta√ß√£o gerada em domingo, 03 de novembro de 2024 √†s 05 horas e 17 minutos

## Vis√£o Geral 

**export_wordlistv2.py** √© o resultado da minha obsess√£o por organiza√ß√£o e an√°lise de dados.  Essa ferramenta, fruto de minhas noites em claro (e de muito caf√© ‚òï),  extrai, processa e exporta listas de palavras de um banco de dados SQLite, gerando relat√≥rios detalhados em JSON e YAML. √â como se o *DataMiner* do filme *Minority Report* encontrasse um primo distante, mas especializado em lexicografia. 

Imagine um cen√°rio onde voc√™ precisa analisar um *corpus* de texto, entender a frequ√™ncia de palavras, a sua estrutura, identificar padr√µes e m√©tricas.  **export_wordlistv2.py** √© a sua solu√ß√£o, meu amigo.  √â a *Matrix* revelando seus segredos, mas ao inv√©s de c√≥digo bin√°rio, s√£o palavras e suas nuances.

## Estrutura e Componentes

O c√≥digo √© dividido em duas partes principais:

* **Classe `WordlistExporterV2`:** A alma do projeto, respons√°vel por extrair, analisar e exportar as palavras. 
* **Fun√ß√£o `main`:** A porta de entrada para o script, respons√°vel por instanciar a classe e orquestrar o processo de exporta√ß√£o.

## Detalhes da Classe `WordlistExporterV2`

**`WordlistExporterV2`**  √© uma classe que encapsula todas as funcionalidades do script. Seus m√©todos s√£o como engrenagens de um rel√≥gio, trabalhando em perfeita sincronia para te entregar um resultado impec√°vel.

### `__init__`

> *Sim, eu gosto de come√ßar pelas bases!*

```python
    def __init__(self):
        self.console = Console()
```

O construtor da classe inicializa a inst√¢ncia da classe `Console` do pacote `rich`.  `Console` √© a minha ferramenta de escolha para exibir informa√ß√µes na tela com um visual aprimorado,  como se o terminal fosse um palco pronto para uma apresenta√ß√£o.  

### `verificar_estrutura_banco`

> *Essa fun√ß√£o √© como uma lupa, examinando cada detalhe da estrutura do banco de dados. √â preciso ter certeza de que a base est√° pronta para a extra√ß√£o!*

```python
    def verificar_estrutura_banco(self, cursor):
        """Verifica as colunas existentes na tabela"""
        cursor.execute("PRAGMA table_info(word_vectors)")
        colunas = {coluna[1] for coluna in cursor.fetchall()}
        return colunas
```

Essa fun√ß√£o recebe um cursor do banco de dados e usa o comando `PRAGMA table_info` para verificar as colunas existentes na tabela `word_vectors`. Retorna um conjunto (`set`) com o nome das colunas. 

### `buscar_palavras_do_banco`

> *Um mergulho no oceano de dados, buscando as p√©rolas que formam a lista de palavras!*

```python
    def buscar_palavras_do_banco(self, cursor, colunas_existentes):
        """Busca palavras do banco adaptando-se √†s colunas existentes"""
        query_base = 'SELECT word, LENGTH(vector) as vector_size'
        
        if 'timestamp' in colunas_existentes:
            query = f"{query_base}, datetime(timestamp) as timestamp FROM word_vectors ORDER BY word"
        else:
            query = f"{query_base}, datetime('now') as timestamp FROM word_vectors ORDER BY word"
            
        cursor.execute(query)
        return cursor.fetchall()
```

Essa fun√ß√£o, usando o poder do SQL, busca as palavras do banco de dados. Ela constr√≥i uma query dinamicamente, adaptando-se √† estrutura da tabela (se a coluna `timestamp` existe ou n√£o). 

### `analisar_palavras`

> *Hora de desvendar os mist√©rios da linguagem! √â aqui que a magia acontece. A an√°lise detalhada das palavras revela suas caracter√≠sticas e padr√µes ocultos.*

```python
    def analisar_palavras(self, palavras: List[str]) -> Dict:
        """An√°lise detalhada das palavras"""
        vogais = set('aeiou√°√©√≠√≥√∫√¢√™√Æ√¥√ª√£√µ√†√®√¨√≤√π√§√´√Ø√∂√º')
        
        stats = {
            'metricas_basicas': {
                'total_palavras': len(palavras),
                'palavras_unicas': len(set(palavras)),
                'comprimento_medio': round(statistics.mean(len(p) for p in palavras), 2),
                'comprimento_mediano': statistics.median(len(p) for p in palavras),
                'desvio_padrao_comprimento': round(statistics.stdev(len(p) for p in palavras), 2) if len(palavras) > 1 else 0,
            },
            'analise_caracteres': {
                'distribuicao_primeira_letra': dict(Counter(p[0].lower() for p in palavras).most_common(10)),
                'chars_especiais': dict(Counter(c for p in palavras for c in p if not c.isalnum()).most_common(10)),
                'vogais_mais_comuns': dict(Counter(c for p in palavras for c in p.lower() if c in vogais).most_common(10)),
                'consoantes_mais_comuns': dict(Counter(c for p in palavras for c in p.lower() if c.isalpha() and c not in vogais).most_common(10))
            },
            'distribuicao_tamanhos': dict(Counter(len(p) for p in palavras)),
            'padroes_linguisticos': {
                'prefixos_comuns': dict(Counter(p[:3] for p in palavras if len(p) > 3).most_common(10)),
                'sufixos_comuns': dict(Counter(p[-3:] for p in palavras if len(p) > 3).most_common(10)),
            },
            'indicadores_estatisticos': {
                'densidade_lexica': round(len(set(palavras)) / len(palavras), 4),
                'palavras_por_tamanho': self.agrupar_por_tamanho(palavras),
                'distribuicao_acentuacao': self.analisar_acentuacao(palavras),
            }
        }
        return stats
```

Essa fun√ß√£o √© um verdadeiro centro de pesquisa da linguagem. Ela recebe uma lista de palavras e realiza uma s√©rie de an√°lises:

* **M√©tricas b√°sicas:** Quantidade total de palavras, n√∫mero de palavras √∫nicas, comprimento m√©dio, comprimento mediano e desvio padr√£o do comprimento das palavras.
* **An√°lise de caracteres:** Distribui√ß√£o da primeira letra das palavras, caracteres especiais mais comuns, vogais mais comuns e consoantes mais comuns.
* **Distribui√ß√£o de tamanhos:** Agrupa as palavras por tamanho, mostrando a quantidade de palavras com cada comprimento.
* **Padr√µes lingu√≠sticos:** Identifica os prefixos e sufixos mais comuns.
* **Indicadores estat√≠sticos:** Calcula a densidade l√©xica (rela√ß√£o entre o n√∫mero de palavras √∫nicas e o n√∫mero total de palavras), agrupa as palavras por tamanho e analisa a distribui√ß√£o de acentua√ß√£o.

### `agrupar_por_tamanho`

> *A organiza√ß√£o √© a chave do sucesso! Essa fun√ß√£o coloca cada palavra no seu devido lugar, agrupando-as por tamanho.*

```python
    def agrupar_por_tamanho(self, palavras: List[str]) -> Dict[int, int]:
        """Agrupa palavras por tamanho"""
        return dict(sorted(Counter(len(p) for p in palavras).items()))
```

Essa fun√ß√£o recebe uma lista de palavras e retorna um dicion√°rio com a contagem das palavras agrupadas por tamanho.

### `analisar_acentuacao`

> *Acentos s√£o como as nuances de um poema, dando ritmo e melodia √† linguagem. Essa fun√ß√£o analisa a presen√ßa de acentos nas palavras.*

```python
    def analisar_acentuacao(self, palavras: List[str]) -> Dict[str, int]:
        """Analisa padr√µes de acentua√ß√£o"""
        acentos = '√°√©√≠√≥√∫√¢√™√Æ√¥√ª√£√µ√†√®√¨√≤√π√§√´√Ø√∂√º'
        return {
            'palavras_com_acento': sum(1 for p in palavras if any(c in p for c in acentos)),
            'palavras_sem_acento': sum(1 for p in palavras if not any(c in p for c in acentos))
        }
```

Essa fun√ß√£o recebe uma lista de palavras e retorna um dicion√°rio com a quantidade de palavras com e sem acentos.

### `exportar_palavras`

> *O momento da verdade! A fun√ß√£o `exportar_palavras` transforma a an√°lise em arquivos concretos, prontos para serem compartilhados e explorados.*

```python
    def exportar_palavras(self):
        """Exporta palavras e an√°lises para JSON e YAML"""
        output_dir = Path('vector-exported-data')
        output_dir.mkdir(exist_ok=True)
        
        try:
            with sqlite3.connect('vetor-words-database-index.db') as conn:
                cursor = conn.cursor()
                
                # Verifica estrutura do banco
                colunas_existentes = self.verificar_estrutura_banco(cursor)
                
                # Busca dados adaptando-se √†s colunas existentes
                resultados = self.buscar_palavras_do_banco(cursor, colunas_existentes)
                
                palavras = [row[0] for row in resultados]
                
                # Realizar an√°lises
                analytics = self.analisar_palavras(palavras)
                
                # Preparar dados para exporta√ß√£o
                data = {
                    'metadata': {
                        'timestamp_export': datetime.now().isoformat(),
                        'total_palavras': len(palavras),
                        'versao_exportador': '2.0.1',
                        'banco_origem': 'ultra-speed-words.db',
                        'colunas_disponiveis': list(colunas_existentes)
                    },
                    'analytics': analytics,
                    'palavras': sorted(palavras)  # Lista ordenada de palavras
                }
                
                # Gerar hash e nomes de arquivo
                hash_arquivo = hashlib.sha256(json.dumps(data, ensure_ascii=False).encode()).hexdigest()[:8]
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                base_filename = f'wordlist_v2_{timestamp}_{hash_arquivo}'
                
                # Exportar JSON
                json_path = output_dir / f'{base_filename}.json'
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)
                
                # Exportar YAML
                yaml_path = output_dir / f'{base_filename}.yaml'
                with open(yaml_path, 'w', encoding='utf-8') as f:
                    yaml.dump(data, f, allow_unicode=True, sort_keys=False)
                
                # Exibir relat√≥rio
                self.exibir_relatorio(data, base_filename)
                
        except Exception as e:
            self.console.print(f"[red]Erro durante a exporta√ß√£o: {str(e)}[/]")
            raise
```

Essa fun√ß√£o, a cereja do bolo, √© respons√°vel por realizar a exporta√ß√£o dos dados para JSON e YAML.  Seu funcionamento √© bem detalhado e demonstra minha paix√£o por c√≥digo limpo e organizado:

1. **Cria o diret√≥rio de sa√≠da:** Define o caminho para o diret√≥rio `vector-exported-data` e cria a pasta caso ela n√£o exista.
2. **Conecta ao banco de dados:** Estabelece a conex√£o com o banco de dados `vetor-words-database-index.db` usando SQLite.
3. **Verifica a estrutura do banco de dados:** Chama a fun√ß√£o `verificar_estrutura_banco` para obter as colunas da tabela `word_vectors`.
4. **Busca as palavras:** Chama a fun√ß√£o `buscar_palavras_do_banco` para extrair as palavras do banco de dados, adaptando-se √† estrutura da tabela.
5. **Realiza a an√°lise das palavras:** Chama a fun√ß√£o `analisar_palavras` para realizar a an√°lise detalhada das palavras.
6. **Prepara os dados para exporta√ß√£o:** Organiza os dados em um dicion√°rio, incluindo metadados, resultados da an√°lise e a lista de palavras ordenada.
7. **Gera o hash e nomes de arquivo:** Calcula o hash do conte√∫do do arquivo para garantir a integridade dos dados, usando o algoritmo SHA-256.
8. **Exporta para JSON:** Cria o arquivo JSON com os dados, usando o m√≥dulo `json` e formatando a sa√≠da de forma organizada.
9. **Exporta para YAML:** Cria o arquivo YAML com os dados, usando o m√≥dulo `yaml`, preservando a estrutura original dos dados e garantindo legibilidade.
10. **Exibe o relat√≥rio:** Chama a fun√ß√£o `exibir_relatorio` para exibir um relat√≥rio detalhado dos resultados da an√°lise.


### `exibir_relatorio`

> *Um relat√≥rio completo, como um relat√≥rio m√©dico detalhado, mas com foco em dados e an√°lise de palavras. √â hora de apresentar os resultados da pesquisa lingu√≠stica!*

```python
    def exibir_relatorio(self, data: Dict, filename: str):
        """Exibe relat√≥rio detalhado com indicadores"""
        self.console.print("\n[bold green]‚ú® Exporta√ß√£o Conclu√≠da com Sucesso![/]\n")
        
        # Tabela principal
        table = Table(title="üìä Resumo da Exporta√ß√£o")
        table.add_column("M√©trica", style="cyan", justify="right")
        table.add_column("Valor", style="magenta")
        
        # M√©tricas b√°sicas
        for key, value in data['analytics']['metricas_basicas'].items():
            table.add_row(
                key.replace('_', ' ').title(),
                f"{value:.2f}" if isinstance(value, float) else str(value)
            )
        
        self.console.print(table)
        
        # Pain√©is de an√°lise
        panels = []
        
        # Distribui√ß√£o de tamanhos
        dist_table = Table(title="üìè Distribui√ß√£o de Tamanhos")
        dist_table.add_column("Tamanho", justify="center")
        dist_table.add_column("Quantidade", justify="right")
        for size, count in sorted(data['analytics']['distribuicao_tamanhos'].items())[:10]:
            dist_table.add_row(str(size), str(count))
        panels.append(Panel(dist_table, title="Distribui√ß√£o"))
        
        # Caracteres mais comuns
        chars_table = Table(title="üî§ Caracteres Mais Comuns")
        chars_table.add_column("Tipo", justify="right")
        chars_table.add_column("Top 5", justify="left")
        for char_type, chars in data['analytics']['analise_caracteres'].items():
            chars_str = ", ".join(f"{c}({n})" for c, n in list(chars.items())[:5])
            chars_table.add_row(char_type.replace('_', ' ').title(), chars_str)
        panels.append(Panel(chars_table, title="Caracteres"))
        
        # Exibir pain√©is
        self.console.print(Columns(panels))
        
        # Informa√ß√µes do arquivo
        self.console.print(f"\n[blue]üìÅ Arquivos gerados:[/]")
        self.console.print(f"  ‚Ä¢ JSON: {filename}.json")
        self.console.print(f"  ‚Ä¢ YAML: {filename}.yaml")
        self.console.print(f"[blue]üîë Hash do conte√∫do:[/] {filename.split('_')[-1]}")
        self.console.print(f"\n[green]‚úÖ Total de palavras exportadas:[/] {data['metadata']['total_palavras']}")
```

Essa fun√ß√£o, como um maestro, organiza a apresenta√ß√£o dos resultados da an√°lise,  usando as funcionalidades do pacote `rich` para criar uma interface de usu√°rio rica e informativa.  Ela apresenta um resumo da exporta√ß√£o em uma tabela,  exibe gr√°ficos e informa√ß√µes sobre a distribui√ß√£o de tamanhos e caracteres, e fornece detalhes sobre os arquivos gerados e o hash do conte√∫do. 

## Fluxo de Execu√ß√£o Principal

A fun√ß√£o `main`, a porta de entrada para o script, √© bem simples, mas poderosa:

```python
if __name__ == '__main__':
    console = Console()
    console.print("[yellow]üöÄ Iniciando exporta√ß√£o da lista de palavras...[/]")
    
    try:
        exporter = WordlistExporterV2()
        exporter.exportar_palavras()
    except Exception as e:
        console.print(f"[red]‚ùå Erro fatal: {str(e)}[/]")
```

Ela cria uma inst√¢ncia da classe `Console` do pacote `rich`, exibe uma mensagem de in√≠cio da exporta√ß√£o, inst√¢ncia a classe `WordlistExporterV2` e chama o m√©todo `exportar_palavras`.  Em caso de erro, exibe uma mensagem de erro na cor vermelha.

## Depend√™ncias e Requisitos

O script `export_wordlistv2.py` depende dos seguintes pacotes Python:

* **sqlite3:** Para interagir com o banco de dados SQLite.
* **json:** Para serializar os dados em formato JSON.
* **yaml:** Para serializar os dados em formato YAML.
* **hashlib:** Para calcular o hash do conte√∫do do arquivo.
* **numpy:** Para manipular dados num√©ricos (embora n√£o seja usado diretamente nesse script).
* **pandas:** Para manipular dados em formato tabular (embora n√£o seja usado diretamente nesse script).
* **datetime:** Para trabalhar com datas e hor√°rios.
* **pathlib:** Para manipular caminhos de arquivos.
* **rich:** Para criar uma interface de usu√°rio rica e informativa.
* **collections:** Para usar a classe `Counter` para contar a frequ√™ncia de elementos.
* **statistics:** Para calcular estat√≠sticas como m√©dia, mediana e desvio padr√£o.
* **dataclasses:** Para definir classes de dados de forma concisa e organizada (embora n√£o seja usado diretamente nesse script).

## Exemplos de Uso

Para usar o script `export_wordlistv2.py`, voc√™ precisa ter um banco de dados SQLite com uma tabela chamada `word_vectors`, contendo pelo menos as colunas `word` e `vector`.

```bash
# Executar o script
python export_wordlistv2.py 
```

## Considera√ß√µes T√©cnicas Importantes

* **Tratamento de Erros:**  O script inclui tratamento de erros b√°sico, mas pode ser aprimorado para lidar com casos espec√≠ficos.
* **Organiza√ß√£o do C√≥digo:**  O c√≥digo √© organizado em classes e m√©todos, facilitando a manuten√ß√£o e reutiliza√ß√£o de c√≥digo.
* **Documenta√ß√£o:**  O script √© bem documentado,  com docstrings detalhadas para cada m√©todo, facilitando a compreens√£o do c√≥digo.
* **Uso de Pacotes:**  O script utiliza pacotes Python de alto n√≠vel, como `rich`,  `yaml` e `json`,  o que aumenta sua efici√™ncia e produtividade.

## Poss√≠veis Melhorias e Recomenda√ß√µes

* **Melhorias no Tratamento de Erros:**  Implementar tratamento de erros mais robusto para lidar com diferentes cen√°rios.
* **Adi√ß√£o de Funcionalidades:**  Criar novas fun√ß√µes de an√°lise, como identificar sin√¥nimos, analisar a estrutura gramatical das palavras ou realizar an√°lise sem√¢ntica.
* **Integra√ß√£o com outros Ferramentas:**  Integrar o script com outras ferramentas de an√°lise de dados, como ferramentas de visualiza√ß√£o ou de processamento de linguagem natural.
* **Teste Automatizado:**  Criar testes automatizados para garantir a qualidade e a corretude do c√≥digo.


## An√°lise de Seguran√ßa e Performance

* **Seguran√ßa:**  O script n√£o apresenta vulnerabilidades de seguran√ßa relevantes, pois n√£o lida com dados sens√≠veis ou acesso a recursos externos.
* **Performance:**  O script √© relativamente r√°pido, principalmente devido ao uso de SQLite e do pacote `rich` para otimizar a interface do usu√°rio.  No entanto, a performance pode ser melhorada com a utiliza√ß√£o de t√©cnicas de otimiza√ß√£o para processamento de dados, como o uso de bibliotecas como `numpy` para opera√ß√µes matem√°ticas mais eficientes.

## Conclus√£o

**export_wordlistv2.py** √© um script Python vers√°til e eficiente para extrair, analisar e exportar listas de palavras de um banco de dados SQLite,  gerando relat√≥rios detalhados.  √â a solu√ß√£o perfeita para  quem precisa de um sistema confi√°vel e completo para lidar com an√°lise de dados lingu√≠sticos.

## Contato

> Se voc√™ est√° pronto para embarcar nessa jornada de descobertas lingu√≠sticas, entre em contato comigo! ü§ù

[![Linkedin](https://img.shields.io/badge/-LinkedIn-blue?style=flat-square&logo=linkedin&logoColor=white)](https://www.linkedin.com/in/itilmgf/)
[![Gmail](https://img.shields.io/badge/-Gmail-c14436?style=flat-square&logo=gmail&logoColor=white)](mailto:oeliasandrade@gmail.com)
[![Whatsapp](https://img.shields.io/badge/-Whatsapp-25D366?style=flat-square&logo=whatsapp&logoColor=white)](https://api.whatsapp.com/send?phone=5544988597116)

## Reposit√≥rios

> Meus reposit√≥rios est√£o cheios de projetos que podem te inspirar! üíª

[![Github](https://img.shields.io/badge/-GitHub-black?style=flat-square&logo=github&logoColor=white)](https://github.com/chaos4455)
[![Github](https://img.shields.io/badge/-GitHub-black?style=flat-square&logo=github&logoColor=white)](https://github.com/evolucaoit)
[![Github](https://img.shields.io/badge/-GitHub-black?style=flat-square&logo=github&logoColor=white)](https://github.com/replika-ai-solutions)

> *"Eu sou o que eu sou, porque eu sou o que eu escolhi ser. N√£o sou um produto do meu passado,  e meu futuro est√° nas minhas m√£os."*  - **O Guia do Mochileiro das Gal√°xias**
