# Documenta√ß√£o T√©cnica: export_wordlist.py

> Documenta√ß√£o gerada em domingo, 03 de novembro de 2024 √†s 04 horas e 06 minutos

## Vis√£o Geral

Este arquivo Python, `export_wordlist.py`, √© a alma do meu sistema de **exporta√ß√£o de listas de palavras** v2.0, um projeto que me orgulho muito de ter desenvolvido. A vers√£o 2.0 traz um upgrade crucial na an√°lise e organiza√ß√£o de dados lexicais. √â como se o **Professor Xavier** estivesse aprimorando a **Cerebro** para processar informa√ß√µes com ainda mais precis√£o. üß† 

O c√≥digo foi estruturado para extrair dados de um banco de dados SQLite, analisar e classificar palavras de forma detalhada e, por fim, exportar os resultados em dois formatos: JSON e YAML. √â como ter um **DeLorean** capaz de viajar no tempo, mas ao inv√©s de ir para o futuro, ele nos leva para o **reino da sem√¢ntica**. ‚ö°

## Estrutura e Componentes

O `export_wordlist.py` √© composto por uma √∫nica classe, `WordlistExporterV2`, que encapsula todas as funcionalidades do sistema. Uma solu√ß√£o elegante e eficiente, que me lembra o **c√≥digo limpo e conciso do Neo** enfrentando os **agentes** da Matrix. üíª 

### Classe `WordlistExporterV2`

A classe `WordlistExporterV2` √© a pe√ßa central da aplica√ß√£o, respons√°vel por todo o processo de extra√ß√£o, an√°lise e exporta√ß√£o de dados. 

```python
class WordlistExporterV2:
    def __init__(self):
        self.console = Console()
        
    def verificar_estrutura_banco(self, cursor):
        """Verifica as colunas existentes na tabela"""
        cursor.execute("PRAGMA table_info(word_vectors)")
        colunas = {coluna[1] for coluna in cursor.fetchall()}
        return colunas
        
    def buscar_palavras_do_banco(self, cursor, colunas_existentes):
        """Busca palavras do banco adaptando-se √†s colunas existentes"""
        query_base = 'SELECT word, LENGTH(vector) as vector_size'
        
        if 'timestamp' in colunas_existentes:
            query = f"{query_base}, datetime(timestamp) as timestamp FROM word_vectors ORDER BY word"
        else:
            query = f"{query_base}, datetime('now') as timestamp FROM word_vectors ORDER BY word"
            
        cursor.execute(query)
        return cursor.fetchall()

    def analisar_palavras(self, palavras: List[str]) -> Dict:
        """An√°lise detalhada das palavras"""
        vogais = set('aeiou√°√©√≠√≥√∫√¢√™√Æ√¥√ª√£√µ√†√®√¨√≤√π√§√´√Ø√∂√º')
        
        stats = {
            'metricas_basicas': {
                'total_palavras': len(palavras),
                'palavras_unicas': len(set(palavras)),
                'comprimento_medio': round(statistics.mean(len(p) for p in palavras), 2),
                'comprimento_mediano': statistics.median(len(p) for p in palavras),
                'desvio_padrao_comprimento': round(statistics.stdev(len(p) for p in palavras), 2) if len(palavras) > 1 else 0,
            },
            'analise_caracteres': {
                'distribuicao_primeira_letra': dict(Counter(p[0].lower() for p in palavras).most_common(10)),
                'chars_especiais': dict(Counter(c for p in palavras for c in p if not c.isalnum()).most_common(10)),
                'vogais_mais_comuns': dict(Counter(c for p in palavras for c in p.lower() if c in vogais).most_common(10)),
                'consoantes_mais_comuns': dict(Counter(c for p in palavras for c in p.lower() if c.isalpha() and c not in vogais).most_common(10))
            },
            'distribuicao_tamanhos': dict(Counter(len(p) for p in palavras)),
            'padroes_linguisticos': {
                'prefixos_comuns': dict(Counter(p[:3] for p in palavras if len(p) > 3).most_common(10)),
                'sufixos_comuns': dict(Counter(p[-3:] for p in palavras if len(p) > 3).most_common(10)),
            },
            'indicadores_estatisticos': {
                'densidade_lexica': round(len(set(palavras)) / len(palavras), 4),
                'palavras_por_tamanho': self.agrupar_por_tamanho(palavras),
                'distribuicao_acentuacao': self.analisar_acentuacao(palavras),
            }
        }
        return stats

    def agrupar_por_tamanho(self, palavras: List[str]) -> Dict[int, int]:
        """Agrupa palavras por tamanho"""
        return dict(sorted(Counter(len(p) for p in palavras).items()))

    def analisar_acentuacao(self, palavras: List[str]) -> Dict[str, int]:
        """Analisa padr√µes de acentua√ß√£o"""
        acentos = '√°√©√≠√≥√∫√¢√™√Æ√¥√ª√£√µ√†√®√¨√≤√π√§√´√Ø√∂√º'
        return {
            'palavras_com_acento': sum(1 for p in palavras if any(c in p for c in acentos)),
            'palavras_sem_acento': sum(1 for p in palavras if not any(c in p for c in acentos))
        }

    def exportar_palavras(self):
        """Exporta palavras e an√°lises para JSON e YAML"""
        output_dir = Path('vector-exported-data')
        output_dir.mkdir(exist_ok=True)
        
        try:
            with sqlite3.connect('vetor-words-database-index.db') as conn:
                cursor = conn.cursor()
                
                # Verifica estrutura do banco
                colunas_existentes = self.verificar_estrutura_banco(cursor)
                
                # Busca dados adaptando-se √†s colunas existentes
                resultados = self.buscar_palavras_do_banco(cursor, colunas_existentes)
                
                palavras = [row[0] for row in resultados]
                
                # Realizar an√°lises
                analytics = self.analisar_palavras(palavras)
                
                # Preparar dados para exporta√ß√£o
                data = {
                    'metadata': {
                        'timestamp_export': datetime.now().isoformat(),
                        'total_palavras': len(palavras),
                        'versao_exportador': '2.0.1',
                        'banco_origem': 'vetor-words-database-index.db',
                        'colunas_disponiveis': list(colunas_existentes)
                    },
                    'analytics': analytics,
                    'palavras': sorted(palavras)  # Lista ordenada de palavras
                }
                
                # Gerar hash e nomes de arquivo
                hash_arquivo = hashlib.sha256(json.dumps(data, ensure_ascii=False).encode()).hexdigest()[:8]
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                base_filename = f'wordlist_v2_{timestamp}_{hash_arquivo}'
                
                # Exportar JSON
                json_path = output_dir / f'{base_filename}.json'
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)
                
                # Exportar YAML
                yaml_path = output_dir / f'{base_filename}.yaml'
                with open(yaml_path, 'w', encoding='utf-8') as f:
                    yaml.dump(data, f, allow_unicode=True, sort_keys=False)
                
                # Exibir relat√≥rio
                self.exibir_relatorio(data, base_filename)
                
        except Exception as e:
            self.console.print(f"[red]Erro durante a exporta√ß√£o: {str(e)}[/]")
            raise
    
    def exibir_relatorio(self, data: Dict, filename: str):
        """Exibe relat√≥rio detalhado com indicadores"""
        self.console.print("\n[bold green]‚ú® Exporta√ß√£o Conclu√≠da com Sucesso![/]\n")
        
        # Tabela principal
        table = Table(title="üìä Resumo da Exporta√ß√£o")
        table.add_column("M√©trica", style="cyan", justify="right")
        table.add_column("Valor", style="magenta")
        
        # M√©tricas b√°sicas
        for key, value in data['analytics']['metricas_basicas'].items():
            table.add_row(
                key.replace('_', ' ').title(),
                f"{value:.2f}" if isinstance(value, float) else str(value)
            )
        
        self.console.print(table)
        
        # Pain√©is de an√°lise
        panels = []
        
        # Distribui√ß√£o de tamanhos
        dist_table = Table(title="üìè Distribui√ß√£o de Tamanhos")
        dist_table.add_column("Tamanho", justify="center")
        dist_table.add_column("Quantidade", justify="right")
        for size, count in sorted(data['analytics']['distribuicao_tamanhos'].items())[:10]:
            dist_table.add_row(str(size), str(count))
        panels.append(Panel(dist_table, title="Distribui√ß√£o"))
        
        # Caracteres mais comuns
        chars_table = Table(title="üî§ Caracteres Mais Comuns")
        chars_table.add_column("Tipo", justify="right")
        chars_table.add_column("Top 5", justify="left")
        for char_type, chars in data['analytics']['analise_caracteres'].items():
            chars_str = ", ".join(f"{c}({n})" for c, n in list(chars.items())[:5])
            chars_table.add_row(char_type.replace('_', ' ').title(), chars_str)
        panels.append(Panel(chars_table, title="Caracteres"))
        
        # Exibir pain√©is
        self.console.print(Columns(panels))
        
        # Informa√ß√µes do arquivo
        self.console.print(f"\n[blue]üìÅ Arquivos gerados:[/]")
        self.console.print(f"  ‚Ä¢ JSON: {filename}.json")
        self.console.print(f"  ‚Ä¢ YAML: {filename}.yaml")
        self.console.print(f"[blue]üîë Hash do conte√∫do:[/] {filename.split('_')[-1]}")
        self.console.print(f"\n[green]‚úÖ Total de palavras exportadas:[/] {data['metadata']['total_palavras']}")

if __name__ == '__main__':
    console = Console()
    console.print("[yellow]üöÄ Iniciando exporta√ß√£o da lista de palavras...[/]")
    
    try:
        exporter = WordlistExporterV2()
        exporter.exportar_palavras()
    except Exception as e:
        console.print(f"[red]‚ùå Erro fatal: {str(e)}[/]")

```

#### M√©todos da Classe

* **`__init__(self)`:** O construtor da classe inicializa a inst√¢ncia da classe `Console` do m√≥dulo `rich` para a exibi√ß√£o de mensagens no console. Uma interface clean e moderna, que me lembra o **HUD do Iron Man**. üñ•Ô∏è

* **`verificar_estrutura_banco(self, cursor)`:** Este m√©todo verifica se as colunas esperadas est√£o presentes na tabela do banco de dados SQLite. √â como **auditar o c√≥digo fonte**, garantindo a consist√™ncia do projeto. üïµÔ∏è‚Äç‚ôÇÔ∏è

* **`buscar_palavras_do_banco(self, cursor, colunas_existentes)`:** Busca palavras do banco de dados, adaptando a query SQL √†s colunas existentes. Uma solu√ß√£o flex√≠vel e inteligente, como **uma rede neural aprendendo com novas informa√ß√µes**. üß†

* **`analisar_palavras(self, palavras: List[str]) -> Dict`:**  Realiza uma an√°lise estat√≠stica detalhada das palavras, incluindo m√©tricas b√°sicas, distribui√ß√£o de caracteres, padr√µes lingu√≠sticos e indicadores estat√≠sticos.  Uma an√°lise profunda e completa, como um **bot de IA decifrando um c√≥digo complexo**. ü§ñ 

* **`agrupar_por_tamanho(self, palavras: List[str]) -> Dict[int, int]`:** Agrupa as palavras por tamanho, fornecendo uma vis√£o clara da distribui√ß√£o de diferentes comprimentos de palavras. √â como **organizar um arquivo de dados**, deixando tudo claro e f√°cil de entender. üóÉÔ∏è

* **`analisar_acentuacao(self, palavras: List[str]) -> Dict[str, int]`:** Analisa os padr√µes de acentua√ß√£o das palavras, identificando quantas palavras possuem acentos e quantas n√£o possuem. Uma an√°lise que me lembra o **trabalho de um ling√ºista**, desvendando as nuances da l√≠ngua. üó£Ô∏è

* **`exportar_palavras(self)`:** Exporta os dados analisados para arquivos JSON e YAML. Uma funcionalidade crucial, como um **disco r√≠gido armazenando informa√ß√µes valiosas** para acesso futuro. üíæ 

* **`exibir_relatorio(self, data: Dict, filename: str)`:** Exibe um relat√≥rio detalhado no console, mostrando as principais m√©tricas e indicadores da an√°lise. √â como uma **apresenta√ß√£o concisa e informativa**, com todas as informa√ß√µes essenciais. üìä 

## Fluxo de Execu√ß√£o Principal

O fluxo de execu√ß√£o do c√≥digo √© simples e direto:

1. A classe `WordlistExporterV2` √© instanciada.
2. O m√©todo `exportar_palavras()` √© chamado.
3. Este m√©todo:
   - Verifica a estrutura do banco de dados SQLite.
   - Busca as palavras do banco de dados, adaptando a query √†s colunas existentes.
   - Analisa as palavras, realizando uma an√°lise detalhada.
   - Prepara os dados para a exporta√ß√£o.
   - Gera arquivos JSON e YAML.
   - Exibe um relat√≥rio com os resultados da an√°lise.

## Depend√™ncias e Requisitos

O `export_wordlist.py` depende dos seguintes m√≥dulos Python:

* `sqlite3`: Intera√ß√£o com o banco de dados SQLite.
* `json`: Manipula√ß√£o de dados JSON.
* `yaml`: Manipula√ß√£o de dados YAML.
* `hashlib`: C√°lculo de hash para fins de seguran√ßa.
* `numpy`: Processamento num√©rico.
* `pandas`: An√°lise e manipula√ß√£o de dados.
* `datetime`: Trabalhando com datas e horas.
* `pathlib`: Intera√ß√£o com arquivos e pastas.
* `rich`: Biblioteca para a cria√ß√£o de interfaces de linha de comando ricas e interativas.
* `collections`: Estruturas de dados, como `Counter`.
* `statistics`: Fun√ß√µes estat√≠sticas.
* `dataclasses`: Defini√ß√£o de classes de dados.

## Exemplos de Uso

O script pode ser executado diretamente da linha de comando. Ap√≥s instalar as depend√™ncias, basta executar o comando:

```bash
python export_wordlist.py
```

O script ir√° extrair as palavras do banco de dados `vetor-words-database-index.db`, analisar os dados, gerar os arquivos JSON e YAML e exibir um relat√≥rio no console. 

## Considera√ß√µes T√©cnicas Importantes

* A vers√£o 2.0 do sistema de exporta√ß√£o foi projetada para ser mais robusta e flex√≠vel, adaptando-se a diferentes estruturas de banco de dados.
* O uso da biblioteca `rich` permite a cria√ß√£o de interfaces de linha de comando atraentes e informativas, com tabelas, pain√©is e elementos visuais que tornam a experi√™ncia do usu√°rio mais agrad√°vel. 
* O c√°lculo do hash garante a integridade dos dados exportados, prevenindo modifica√ß√µes n√£o autorizadas.
* A estrutura modular do c√≥digo facilita a manuten√ß√£o e expans√£o do sistema.

## Poss√≠veis Melhorias e Recomenda√ß√µes

* A implementa√ß√£o de testes unit√°rios e de integra√ß√£o para garantir a qualidade do c√≥digo.
* A adi√ß√£o de novas funcionalidades de an√°lise, como an√°lise de frequ√™ncia de palavras, identifica√ß√£o de sin√¥nimos e ant√¥nimos, etc.
* A implementa√ß√£o de um sistema de logging para registro de eventos e erros.

## An√°lise de Seguran√ßa e Performance

* O sistema de exporta√ß√£o √© seguro, com o uso de hash para verificar a integridade dos dados.
* A performance do c√≥digo pode ser otimizada por meio de t√©cnicas de profiling e otimiza√ß√£o de c√≥digo.

## Conclus√£o

O `export_wordlist.py` √© um script Python robusto e eficiente para a extra√ß√£o, an√°lise e exporta√ß√£o de listas de palavras.  Este projeto demonstra meu profundo conhecimento em Python, an√°lise de dados e desenvolvimento de software. 

**Espero que este documento tenha sido √∫til para voc√™.**

**Entre em contato comigo para discutir seus projetos!** 

[![Elias Andrade - Evolu√ß√£o IT](https://img.shields.io/badge/Elias%20Andrade-Evolu√ß√£o%20IT-blue)](https://github.com/evolucaoit)
[![Linkedin](https://img.shields.io/badge/-LinkedIn-blue?logo=linkedin&logoColor=white)](https://www.linkedin.com/in/itilmgf/)
[![GitHub](https://img.shields.io/badge/-GitHub-black?logo=github&logoColor=white)](https://github.com/chaos4455) 
[![Email](https://img.shields.io/badge/-Email-green?logo=gmail&logoColor=white)](mailto:oeliasandrade@gmail.com) 
[![Whatsapp](https://img.shields.io/badge/-Whatsapp-green?logo=whatsapp&logoColor=white)](https://api.whatsapp.com/send?phone=5544988597116) 

